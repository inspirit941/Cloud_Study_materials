1
00:00:09,420 --> 00:00:14,670
이 비디오에서는 Kubernetes 시스템의 아키텍처에 대해 알아봅니다.

2
00:00:14,670 --> 00:00:20,590
Kubernetes 공식 문서에 있는 이 다이어그램은 Kubernetes의 주요 구성요소를 강조합니다.

3
00:00:20,590 --> 00:00:25,140
Kubernetes의 개별 배포단위를 "클러스터"라고 합니다.

4
00:00:25,140 --> 00:00:30,630
다이어그램의 왼쪽은 Control plane입니다. 클러스터에 관련된 결정을 내리고

5
00:00:30,630 --> 00:00:34,740
클러스터에서 발생하는 이벤트를 감지하고 응답하는 역할을 합니다.

6
00:00:34,740 --> 00:00:40,110
Control Plane에서 내리는 결정의 예는 워크로드 스케줄링입니다.

7
00:00:40,110 --> 00:00:46,780
이벤트에 응답하는 예는 애플리케이션이 배포되었을 때 새 리소스를 생성하는 것입니다.

8
00:00:46,780 --> 00:00:53,570
Control Plane은 몇 가지 구성요소로 이루어져 있습니다. 첫 번째로는 Kubernetes API 서버입니다.

9
00:00:53,570 --> 00:00:59,159
클러스터의 모든 통신은 이 API를 사용합니다.

10
00:00:59,159 --> 00:01:04,280
예컨대 Kubernetes API 서버는 클러스터의 상태를 조회하거나

11
00:01:04,280 --> 00:01:08,340
상태를 변경하라는 명령어를 입력받습니다.

12
00:01:08,340 --> 00:01:14,539
다음은 Etcd로, 클러스터의 모든 데이터를 저장하는 가용성 높은 key-value 저장소입니다.

13
00:01:14,539 --> 00:01:20,270
Kubernetes으로 애플리케이션을 배포하면, 배포에 관련된 모든 구성사항은

14
00:01:20,270 --> 00:01:24,890
etcd에 저장됩니다. 따라서 Etcd는 클러스터의 상태를 저장하는 진실의 보고이며,

15
00:01:24,890 --> 00:01:29,829
Kubernetes는 클러스터의 상태가 etcd에 저장된 상태와 일치하도록 작동합니다.

16
00:01:29,829 --> 00:01:35,430
Kubernetes 스케줄러는 새로 생성된 Pods을 노드에 할당합니다.

17
00:01:35,430 --> 00:01:39,509
이는, 워크로드가 클러스터 내 어디에서 실행되어야 하는지를

18
00:01:39,509 --> 00:01:45,610
스케줄러가 결정한다는 의미입니다. Pods와 노드는 곧 배우게 될 것입니다.

19
00:01:45,610 --> 00:01:50,970
Kubernetes 컨트롤러 관리자는 클러스터의 상태를 확인하고, 현재 클러스터의 상태가

20
00:01:50,970 --> 00:01:57,359
원하는 클러스터 상태와 일치하도록 하는 컨트롤러 프로세스를 실행합니다.

21
00:01:57,359 --> 00:02:02,909
컨트롤러에 대해서도 곧 다룰 것입니다. 마지막으로, 클라우드 컨트롤러 관리자는

22
00:02:02,909 --> 00:02:07,530
기반에 있는 클라우드 서비스 제공자와 상호작용할 수 있는 컨트롤러를 실행합니다.

23
00:02:07,530 --> 00:02:12,940
이 컨트롤러는 클러스터와 클라우드 서비스 제공자의 API를 연결해 줍니다.

24
00:02:12,940 --> 00:02:18,580
Kubernetes는 본질적으로 오픈 소스 소프트웨어이므로, 다양한 조직과 클라우드 서비스 제공자가 사용을 지원하는 것이 이상적인 그림입니다.

25
00:02:18,580 --> 00:02:25,450
따라서 Kubernetes 자체는 특정 클라우드 서비스에 구애받지 않도록 노력하고 있습니다.

26
00:02:25,450 --> 00:02:31,069
클라우드 컨트롤러 관리자는 Kubernetes와 클라우드 서비스 제공자 모두가

27
00:02:31,069 --> 00:02:35,489
다른 의존성 없이 성공적으로 발전할 수 있도록 하는 역할입니다.

28
00:02:35,489 --> 00:02:38,760
지금까지가 Control Plane의 내용이었습니다.

29
00:02:38,760 --> 00:02:44,689
이제 오른쪽으로 넘어가서, worker 노드에 관련된 내용을 보겠습니다.

30
00:02:44,689 --> 00:02:47,900
노드는 Kubernetes 클러스터에 있는 worker 머신입니다.

31
00:02:47,900 --> 00:02:52,610
즉, 사용자의 애플리케이션은 노드에서 실행됩니다.

32
00:02:52,610 --> 00:02:58,349
노드는 가상머신일 수도, 실제 머신일 수도 있습니다. 각각의 노드는

33
00:02:58,349 --> 00:03:04,660
Control Planed이 관리하며, Pods를 실행할 수 있습니다. Pods는 다음 강의에서 더 자세히 배우게 됩니다.

34
00:03:04,660 --> 00:03:10,370
노드는 Kubernetes가 생성하는 게 아니라, 클라우드 서비스 제공자가 생성합니다.

35
00:03:10,370 --> 00:03:14,709
이 특징 때문에, Kubernetes는 다양한 인프라에서 실행될 수 있습니다.

36
00:03:14,709 --> 00:03:18,010
노드는 Control Plane이 제어합니다.

37
00:03:18,010 --> 00:03:22,560
노드가 Pods를 실행할 수 있도록 하는, 노드의 몇 가지 구성요소들이 있습니다.

38
00:03:22,560 --> 00:03:26,040
첫 번째는 가장 중요한 구성 요소 인 "kubelet"입니다.

39
00:03:26,040 --> 00:03:32,290
kubelet은 Kubernetes API 서버와 통신해서 새 Pod 정보를 받아옵니다.

40
00:03:32,290 --> 00:03:38,240
그리고 해당 Pods와 관련 컨테이너들이 의도한 대로 작동하는지 확인합니다.

41
00:03:38,240 --> 00:03:42,469
Control Plane에 상태를 보고하는 일도 담당합니다.

42
00:03:42,469 --> 00:03:47,430
Kubelet은 Pod을 시작하기 위해

43
00:03:47,430 --> 00:03:51,879
Container runtime을 사용합니다.

44
00:03:51,879 --> 00:03:57,810
Container runtime은 이미지를 다운받고, 컨테이너를 실행하는 역할을 합니다.

45
00:03:57,810 --> 00:04:03,269
단일 Container runtime을 제공하는 대신, Kubernetes는 

46
00:04:03,269 --> 00:04:08,060
Container runtime과 착탈식으로 연결할 수 있는 인터페이스를 제공합니다.

47
00:04:08,060 --> 00:04:15,700
도커가 가장 유명한 runtime이고, rkt나 CRI-O도 자주 쓰이는 Container runtime입니다.

48
00:04:15,700 --> 00:04:21,130
마지막으로 Kubernetes proxy는 클러스터 내 각각의 노드에서 실행되는

49
00:04:21,130 --> 00:04:27,650
네트워크 프록시입니다. 이 프록시는 노드에서 실행되는

50
00:04:27,650 --> 00:04:34,990
Pods의 통신 - 다시 말해, 클러스터에서 실행되는 워크로드 간 통신 - 을 통제합니다.

51
00:04:34,990 --> 00:04:39,160
이런 통신은 클러스터 내부 또는 외부에서 발생할 수 있습니다.

52
00:04:39,160 --> 00:04:44,390
지금까지 컨트롤러를 몇 번 언급했습니다.

53
00:04:44,390 --> 00:04:49,540
컨트롤러의 역할은 현재 상태가 원하는 상태와 일치하도록 만드는 것이었습니다.

54
00:04:49,540 --> 00:04:55,010
보다 쉽게 이해하기 위해, Kubernetes 공식 문서는 다음과 같은 훌륭한 정의와 비유를 들었습니다.

55
00:04:55,010 --> 00:05:00,940
Control loop는 시스템 상태를 통제하는 무한 루프입니다.

56
00:05:00,940 --> 00:05:07,690
온도 조절기에 비유할 수 있습니다.

57
00:05:07,690 --> 00:05:12,920
온도 조절기에서, 원하는 온도를 세팅하는 것처럼요.

58
00:05:12,920 --> 00:05:20,310
예컨대 70°F로 설정했다면, 방에 설치된 온도 조절기는 

59
00:05:20,310 --> 00:05:25,930
실제 상태를 (방의 온도) 원하는 상태에 근접하도록 (온도 조절기에 설정된 온도)

60
00:05:25,930 --> 00:05:30,380
끊임없이 동작하는 것과 같습니다. Kubernetes의 컨트롤러도 이와 같습니다.

61
00:05:30,380 --> 00:05:35,540
Kubernetes 클러스터의 상태를 관찰하고, 현재 상태가

62
00:05:35,540 --> 00:05:41,010
목표한 상태에 도달하도록 작업하는 것이죠. 일반적으로, 컨트롤러는

63
00:05:41,010 --> 00:05:46,990
현재 상태와 원하는 상태를 맞추는 작업을 시작하기 위해

64
00:05:46,990 --> 00:05:51,560
API 서버에 메시지를 보냅니다. 또한 Kubernetes 컨트롤러는 Kubernetes 객체를 추적합니다.

65
00:05:51,560 --> 00:05:55,260
만약 세 개의 애플리케이션 인스턴스가

66
00:05:55,260 --> 00:06:00,780
Kubernetes에서 실행되도록 설정했다면, 컨트롤러는

67
00:06:00,780 --> 00:06:05,990
클러스터의 상태를 확인하고, 제약조건 하에서

68
00:06:05,990 --> 00:06:11,900
세 개의 인스턴스가 어느 때라도 정상적으로 작동할 수 있도록

69
00:06:11,900 --> 00:06:15,310
최선을 다합니다. Kubernetes 객체와 컨트롤러에 관해서는

70
00:06:15,310 --> 00:06:20,370
다음 강의에서 더 자세히 알아봅니다. 이제 여러분은 Kubernetes 클러스터의

71
00:06:20,370 --> 00:06:24,560
아키텍처에 어느 정도 익숙해졌을 것입니다. 여러 개의 구성요소로 이루어진

72
00:06:24,560 --> 00:06:31,280
Control Plane은 클러스터에 관련된 전역 결정을 내리는 역할을 합니다.

73
00:06:31,280 --> 00:06:35,560
또한, Kubernetes의 중요한 구성요소를 실행하는 노드가 있고

74
00:06:35,560 --> 00:06:40,060
사용자가 배포한 워크로드를 클러스터에서 수행하는 노드가 있다는 것을 배웠습니다.

75
00:06:40,060 --> 00:06:45,340
마지막으로, 컨트롤러가 무엇이며 Kubernetes가 최적 상태를 찾아가기 위해

76
00:06:45,340 --> 00:06:50,210
컨트롤러를 어떻게 사용하는지 보았습니다. 다음 강의에서는 Kubernetes 객체가 무엇인지,

77
00:06:50,210 --> 00:06:53,790
클러스터에서 생성되는 리소스에는 어떤 것들이 있는지 보겠습니다.

